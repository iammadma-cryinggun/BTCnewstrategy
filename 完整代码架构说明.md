# å®Œæ•´ä»£ç æ¶æ„ - æ‰€æœ‰éœ€è¦çš„æ¨¡å—

**ç‰ˆæœ¬**: v2.0 åŸºäºéªŒè¯5é€»è¾‘
**æ—¥æœŸ**: 2026-01-22

---

## ğŸ“‹ å®Œæ•´æ¨¡å—æ¸…å•

ç³»ç»Ÿéœ€è¦ä»¥ä¸‹**9å¤§æ¨¡å—**ï¼Œå…±**25ä¸ªå­æ¨¡å—**ï¼š

```
å®Œæ•´ç³»ç»Ÿ
â”‚
â”œâ”€ æ¨¡å—1ï¼šæ•°æ®è·å–å±‚ï¼ˆç¬¬0å±‚ï¼‰
â”‚   â”œâ”€ 1.1 BTCæ•°æ®è·å–
â”‚   â”œâ”€ 1.2 DXYæ•°æ®è·å–
â”‚   â””â”€ 1.3 æ•°æ®ç¼“å­˜ç®¡ç†
â”‚
â”œâ”€ æ¨¡å—2ï¼šç‰©ç†æŒ‡æ ‡è®¡ç®—ï¼ˆç¬¬1å±‚ - éªŒè¯5æ ¸å¿ƒï¼‰
â”‚   â”œâ”€ 2.1 æ•°æ®é¢„å¤„ç†ï¼ˆå»è¶‹åŠ¿ï¼‰
â”‚   â”œâ”€ 2.2 FFTæ»¤æ³¢
â”‚   â”œâ”€ 2.3 Hilbertå˜æ¢
â”‚   â”œâ”€ 2.4 å¼ åŠ›æ ‡å‡†åŒ–
â”‚   â”œâ”€ 2.5 åŠ é€Ÿåº¦è®¡ç®—ï¼ˆäºŒé˜¶å·®åˆ†ï¼‰
â”‚   â””â”€ 2.6 DXYç‡ƒæ–™è®¡ç®—
â”‚
â”œâ”€ æ¨¡å—3ï¼šå¸‚åœºçŠ¶æ€è¯Šæ–­ï¼ˆç¬¬2å±‚ï¼‰
â”‚   â”œâ”€ 3.1 ä¿¡å·åˆ†ç±»ï¼ˆ6ç§çŠ¶æ€ï¼‰
â”‚   â”œâ”€ 3.2 ç½®ä¿¡åº¦è¯„ä¼°
â”‚   â””â”€ 3.3 DXYå¢å¼ºåˆ¤æ–­
â”‚
â”œâ”€ æ¨¡å—4ï¼šäº¤æ˜“å†³ç­–ï¼ˆç¬¬3å±‚ï¼‰
â”‚   â”œâ”€ 4.1 V8.0åå‘ç­–ç•¥æ˜ å°„
â”‚   â”œâ”€ 4.2 åŸºç¡€ä»“ä½è®¡ç®—
â”‚   â”œâ”€ 4.3 DXYå¢å¼ºä»“ä½
â”‚   â””â”€ 4.4 é£é™©æ§åˆ¶ä»“ä½
â”‚
â”œâ”€ æ¨¡å—5ï¼šé£é™©ç®¡ç†ï¼ˆç¬¬4å±‚ï¼‰
â”‚   â”œâ”€ 5.1 æ­¢æŸè®¾ç½®
â”‚   â”œâ”€ 5.2 æ­¢ç›ˆè®¾ç½®
â”‚   â”œâ”€ 5.3 ä¿¡å·æ¶ˆå¤±æ£€æµ‹
â”‚   â””â”€ 5.4 æŒä»“ç›‘æ§
â”‚
â”œâ”€ æ¨¡å—6ï¼šè®¢å•æ‰§è¡Œ
â”‚   â”œâ”€ 6.1 å¼€ä»“é€»è¾‘
â”‚   â”œâ”€ 6.2 å¹³ä»“é€»è¾‘
â”‚   â””â”€ 6.3 ä»“ä½æ›´æ–°
â”‚
â”œâ”€ æ¨¡å—7ï¼šæ—¥å¿—è®°å½•
â”‚   â”œâ”€ 7.1 äº¤æ˜“æ—¥å¿—
â”‚   â”œâ”€ 7.2 æ€§èƒ½ç»Ÿè®¡
â”‚   â””â”€ 7.3 æ•°æ®ä¿å­˜
â”‚
â”œâ”€ æ¨¡å—8ï¼šä¸»å¾ªç¯æ§åˆ¶
â”‚   â”œâ”€ 8.1 å®šæ—¶æ£€æŸ¥
â”‚   â”œâ”€ 8.2 çŠ¶æ€ç®¡ç†
â”‚   â””â”€ 8.3 é”™è¯¯å¤„ç†
â”‚
â””â”€ æ¨¡å—9ï¼šæ•°æ®æ”¶é›†ï¼ˆç‹¬ç«‹è¿›ç¨‹ï¼‰
    â”œâ”€ 9.1 å®šæ—¶æ”¶é›†
    â”œâ”€ 9.2 æ•°æ®å­˜å‚¨
    â””â”€ 9.3 å†å²ç®¡ç†
```

---

## ğŸ”§ æ¨¡å—è¯¦ç»†è¯´æ˜

### æ¨¡å—1ï¼šæ•°æ®è·å–å±‚ï¼ˆç¬¬0å±‚ï¼‰

#### 1.1 BTCæ•°æ®è·å–

**åŠŸèƒ½**ï¼šä»Binanceè·å–BTC 4å°æ—¶Kçº¿æ•°æ®

**éœ€è¦çš„ä»£ç **ï¼š
```python
class BTCDataFetcher:
    """BTCæ•°æ®è·å–å™¨"""

    def __init__(self):
        self.base_url = "https://api.binance.com/api/v3/klines"
        self.symbol = "BTCUSDT"
        self.interval = "4h"
        self.limit = 1000  # è·å–1000æ ¹Kçº¿

    def fetch(self) -> Optional[pd.DataFrame]:
        """è·å–BTC 4å°æ—¶Kçº¿æ•°æ®

        è¿”å›:
            DataFrame with columns:
            - timestamp: æ—¶é—´æˆ³
            - open: å¼€ç›˜ä»·
            - high: æœ€é«˜ä»·
            - low: æœ€ä½ä»·
            - close: æ”¶ç›˜ä»·
            - volume: æˆäº¤é‡
        """
        try:
            params = {
                'symbol': self.symbol,
                'interval': self.interval,
                'limit': self.limit
            }
            response = requests.get(self.base_url, params=params, timeout=15)
            response.raise_for_status()
            data = response.json()

            # è½¬æ¢ä¸ºDataFrame
            df = pd.DataFrame(data, columns=[
                'timestamp', 'open', 'high', 'low', 'close', 'volume',
                'close_time', 'quote_volume', 'trades', 'taker_buy_base',
                'taker_buy_quote', 'ignore'
            ])

            # æ•°æ®ç±»å‹è½¬æ¢
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            for col in ['open', 'high', 'low', 'close', 'volume']:
                df[col] = df[col].astype(float)

            df.set_index('timestamp', inplace=True)

            return df

        except Exception as e:
            print(f"[ERROR] BTCæ•°æ®è·å–å¤±è´¥: {e}")
            return None
```

---

#### 1.2 DXYæ•°æ®è·å–

**åŠŸèƒ½**ï¼šä»FREDè·å–ç¾å…ƒæŒ‡æ•°æ•°æ®

**éœ€è¦çš„ä»£ç **ï¼š
```python
class DXYDataFetcher:
    """DXYç¾å…ƒæŒ‡æ•°æ•°æ®è·å–å™¨"""

    def __init__(self):
        self.base_url = "https://fred.stlouisfed.org/graph/fredgraph.csv"
        self.series_id = "DTWEXBGS"

    def fetch(self, days_back: int = 30) -> Optional[pd.DataFrame]:
        """è·å–DXYç¾å…ƒæŒ‡æ•°æ•°æ®

        å‚æ•°:
            days_back: è·å–æœ€è¿‘å¤šå°‘å¤©çš„æ•°æ®

        è¿”å›:
            DataFrame with columns:
            - observation_date: æ—¥æœŸ
            - Close: DXYæ”¶ç›˜ä»·
        """
        try:
            url = f"{self.base_url}?id={self.series_id}"
            response = requests.get(url, timeout=15)

            if response.status_code != 200:
                print(f"[WARNING] DXYæ•°æ®è·å–å¤±è´¥: HTTP {response.status_code}")
                return None

            # è§£æCSV
            from io import StringIO
            dxy_df = pd.read_csv(StringIO(response.text))
            dxy_df['observation_date'] = pd.to_datetime(dxy_df['observation_date'])
            dxy_df.set_index('observation_date', inplace=True)
            dxy_df.rename(columns={'DTWEXBGS': 'Close'}, inplace=True)
            dxy_df = dxy_df.dropna()
            dxy_df['Close'] = pd.to_numeric(dxy_df['Close'], errors='coerce')

            # åªå–æœ€è¿‘çš„æ•°æ®
            cutoff_date = datetime.now() - timedelta(days=days_back)
            dxy_df = dxy_df[dxy_df.index >= cutoff_date]

            return dxy_df

        except Exception as e:
            print(f"[WARNING] DXYæ•°æ®è·å–å¤±è´¥: {e}")
            return None
```

---

#### 1.3 æ•°æ®ç¼“å­˜ç®¡ç†

**åŠŸèƒ½**ï¼šç®¡ç†å†å²æ•°æ®ç¼“å­˜

**éœ€è¦çš„ä»£ç **ï¼š
```python
class DataCache:
    """æ•°æ®ç¼“å­˜ç®¡ç†å™¨"""

    def __init__(self, max_size: int = 100):
        self.max_size = max_size
        self.price_history: List[float] = []  # ä»·æ ¼å†å²
        self.volume_history: List[float] = []  # æˆäº¤é‡å†å²
        self.dxy_history: List[float] = []     # DXYå†å²

    def update_price(self, price: float, volume: float):
        """æ›´æ–°ä»·æ ¼å’Œæˆäº¤é‡å†å²"""
        self.price_history.append(price)
        self.volume_history.append(volume)

        # ä¿æŒæœ€å¤§é•¿åº¦
        if len(self.price_history) > self.max_size:
            self.price_history.pop(0)
            self.volume_history.pop(0)

    def update_dxy(self, dxy: float):
        """æ›´æ–°DXYå†å²"""
        self.dxy_history.append(dxy)

        # ä¿æŒæœ€å¤§é•¿åº¦
        if len(self.dxy_history) > 10:  # DXYåªéœ€è¦ä¿ç•™æœ€è¿‘10ä¸ª
            self.dxy_history.pop(0)

    def get_prices_array(self) -> np.ndarray:
        """è·å–ä»·æ ¼æ•°ç»„"""
        return np.array(self.price_history)

    def is_ready(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿæ•°æ®"""
        return len(self.price_history) >= 60
```

---

### æ¨¡å—2ï¼šç‰©ç†æŒ‡æ ‡è®¡ç®—ï¼ˆç¬¬1å±‚ - éªŒè¯5æ ¸å¿ƒï¼‰

è¿™æ˜¯ç³»ç»Ÿæœ€æ ¸å¿ƒçš„éƒ¨åˆ†ï¼Œéœ€è¦6ä¸ªå­æ¨¡å—ã€‚

---

#### 2.1 æ•°æ®é¢„å¤„ç†ï¼ˆå»è¶‹åŠ¿ï¼‰

**åŠŸèƒ½**ï¼šç§»é™¤ä»·æ ¼åºåˆ—çš„çº¿æ€§è¶‹åŠ¿

**éœ€è¦çš„ä»£ç **ï¼š
```python
from scipy.signal import detrend

def preprocess_prices(prices: np.ndarray) -> np.ndarray:
    """é¢„å¤„ç†ä»·æ ¼æ•°æ®ï¼šå»è¶‹åŠ¿

    å‚æ•°:
        prices: ä»·æ ¼åºåˆ—

    è¿”å›:
        å»è¶‹åŠ¿åçš„ä»·æ ¼åºåˆ—
    """
    try:
        # å»è¶‹åŠ¿ï¼šç§»é™¤çº¿æ€§è¶‹åŠ¿ï¼Œåªä¿ç•™æ³¢åŠ¨
        d_prices = detrend(prices, type='linear')
        return d_prices
    except Exception as e:
        print(f"[ERROR] æ•°æ®é¢„å¤„ç†å¤±è´¥: {e}")
        return prices
```

---

#### 2.2 FFTæ»¤æ³¢

**åŠŸèƒ½**ï¼šå¿«é€Ÿå‚…é‡Œå¶å˜æ¢æ»¤æ³¢ï¼Œå»é™¤é«˜é¢‘å™ªéŸ³

**éœ€è¦çš„ä»£ç **ï¼š
```python
from scipy.fft import fft, ifft

def fft_filter(prices: np.ndarray, n_components: int = 8) -> np.ndarray:
    """FFTæ»¤æ³¢

    å‚æ•°:
        prices: ä»·æ ¼åºåˆ—ï¼ˆå»è¶‹åŠ¿åï¼‰
        n_components: ä¿ç•™çš„é¢‘ç‡åˆ†é‡æ•°é‡

    è¿”å›:
        æ»¤æ³¢åçš„ä»·æ ¼åºåˆ—
    """
    try:
        # FFTå˜æ¢
        coeffs = fft(prices)

        # ä¿ç•™å‰n_componentsä¸ªé¢‘ç‡åˆ†é‡
        coeffs[n_components:] = 0

        # é€†FFTå˜æ¢
        filtered = ifft(coeffs).real

        return filtered

    except Exception as e:
        print(f"[ERROR] FFTæ»¤æ³¢å¤±è´¥: {e}")
        return prices
```

---

#### 2.3 Hilbertå˜æ¢

**åŠŸèƒ½**ï¼šHilbertå˜æ¢ï¼Œæå–è™šéƒ¨ä½œä¸ºå¼ åŠ›

**éœ€è¦çš„ä»£ç **ï¼š
```python
from scipy.signal import hilbert

def hilbert_transform(filtered_prices: np.ndarray) -> np.ndarray:
    """Hilbertå˜æ¢ï¼Œæå–å¼ åŠ›

    å‚æ•°:
        filtered_prices: æ»¤æ³¢åçš„ä»·æ ¼åºåˆ—

    è¿”å›:
        å¼ åŠ›åºåˆ—ï¼ˆHilbertå˜æ¢çš„è™šéƒ¨ï¼‰
    """
    try:
        # Hilbertå˜æ¢
        analytic = hilbert(filtered_prices)

        # æå–è™šéƒ¨ä½œä¸ºå¼ åŠ›
        tension = np.imag(analytic)

        return tension

    except Exception as e:
        print(f"[ERROR] Hilbertå˜æ¢å¤±è´¥: {e}")
        return np.zeros_like(filtered_prices)
```

---

#### 2.4 å¼ åŠ›æ ‡å‡†åŒ–

**åŠŸèƒ½**ï¼šæ ‡å‡†åŒ–å¼ åŠ›åˆ°å‡å€¼0ã€æ ‡å‡†å·®1

**éœ€è¦çš„ä»£ç **ï¼š
```python
def normalize_tension(tension: np.ndarray) -> np.ndarray:
    """æ ‡å‡†åŒ–å¼ åŠ›

    å‚æ•°:
        tension: å¼ åŠ›åºåˆ—

    è¿”å›:
        æ ‡å‡†åŒ–åçš„å¼ åŠ›åºåˆ—
    """
    try:
        # æ ‡å‡†åŒ–ï¼š(x - mean) / std
        if len(tension) > 1 and np.std(tension) > 0:
            norm_tension = (tension - np.mean(tension)) / np.std(tension)
        else:
            norm_tension = tension

        return norm_tension

    except Exception as e:
        print(f"[ERROR] å¼ åŠ›æ ‡å‡†åŒ–å¤±è´¥: {e}")
        return tension
```

---

#### 2.5 åŠ é€Ÿåº¦è®¡ç®—ï¼ˆäºŒé˜¶å·®åˆ†ï¼‰

**åŠŸèƒ½**ï¼šè®¡ç®—å¼ åŠ›çš„äºŒé˜¶å·®åˆ†ä½œä¸ºåŠ é€Ÿåº¦ï¼ˆå…³é”®ï¼ï¼‰

**éœ€è¦çš„ä»£ç **ï¼š
```python
def calculate_acceleration(norm_tension: np.ndarray) -> Tuple[Optional[float], Optional[float]]:
    """è®¡ç®—åŠ é€Ÿåº¦ï¼ˆå¼ åŠ›çš„äºŒé˜¶å·®åˆ†ï¼‰

    è¿™æ˜¯éªŒè¯5é€»è¾‘çš„æ ¸å¿ƒï¼

    å‚æ•°:
        norm_tension: æ ‡å‡†åŒ–åçš„å¼ åŠ›åºåˆ—

    è¿”å›:
        (å½“å‰å¼ åŠ›, åŠ é€Ÿåº¦)
    """
    if len(norm_tension) < 3:
        return None, None

    try:
        # å½“å‰å¼ åŠ›
        current_tension = norm_tension[-1]

        # å‰ä¸€æ¬¡å¼ åŠ›
        prev_tension = norm_tension[-2]

        # å‰ä¸¤æ¬¡å¼ åŠ›
        prev2_tension = norm_tension[-3]

        # é€Ÿåº¦ = å¼ åŠ›çš„ä¸€é˜¶å·®åˆ†
        velocity = current_tension - prev_tension

        # åŠ é€Ÿåº¦ = é€Ÿåº¦çš„ä¸€é˜¶å·®åˆ† = å¼ åŠ›çš„äºŒé˜¶å·®åˆ†
        acceleration = velocity - (prev_tension - prev2_tension)

        return float(current_tension), float(acceleration)

    except Exception as e:
        print(f"[ERROR] åŠ é€Ÿåº¦è®¡ç®—å¤±è´¥: {e}")
        return None, None
```

---

#### 2.6 DXYç‡ƒæ–™è®¡ç®—

**åŠŸèƒ½**ï¼šè®¡ç®—DXYç‡ƒæ–™

**éœ€è¦çš„ä»£ç **ï¼š
```python
def calculate_dxy_fuel(dxy_history: List[float]) -> float:
    """è®¡ç®—DXYç‡ƒæ–™

    å‚æ•°:
        dxy_history: DXYå†å²æ•°æ®

    è¿”å›:
        DXYç‡ƒæ–™å€¼
    """
    if len(dxy_history) < 3:
        return 0.0

    try:
        closes = np.array(dxy_history)

        # è®¡ç®—å˜åŒ–ç‡
        change_1 = (closes[-1] - closes[-2]) / closes[-2]
        change_2 = (closes[-2] - closes[-3]) / closes[-3] if len(closes) >= 3 else change_1

        # è®¡ç®—åŠ é€Ÿåº¦
        acceleration = change_1 - change_2

        # DXYç‡ƒæ–™ = -åŠ é€Ÿåº¦ Ã— 100
        fuel = -acceleration * 100

        return float(fuel)

    except Exception as e:
        print(f"[ERROR] DXYç‡ƒæ–™è®¡ç®—å¤±è´¥: {e}")
        return 0.0
```

---

### æ¨¡å—3ï¼šå¸‚åœºçŠ¶æ€è¯Šæ–­ï¼ˆç¬¬2å±‚ï¼‰

#### 3.1 ä¿¡å·åˆ†ç±»ï¼ˆ6ç§çŠ¶æ€ï¼‰

**åŠŸèƒ½**ï¼šæ ¹æ®å¼ åŠ›å’ŒåŠ é€Ÿåº¦åˆ†ç±»å¸‚åœºçŠ¶æ€

**éœ€è¦çš„ä»£ç **ï¼š
```python
class MarketStateClassifier:
    """å¸‚åœºçŠ¶æ€åˆ†ç±»å™¨"""

    def __init__(self):
        # éªŒè¯5å‚æ•°
        self.TENSION_THRESHOLD = 0.35
        self.ACCEL_THRESHOLD = 0.02
        self.OSCILLATION_BAND = 0.5

    def classify(self,
                tension: float,
                acceleration: float,
                dxy_fuel: float = 0.0) -> Tuple[str, str, float]:
        """åˆ†ç±»å¸‚åœºçŠ¶æ€

        å‚æ•°:
            tension: å¼ åŠ›
            acceleration: åŠ é€Ÿåº¦
            dxy_fuel: DXYç‡ƒæ–™

        è¿”å›:
            (ä¿¡å·ç±»å‹, æè¿°, ç½®ä¿¡åº¦)
        """

        # 1. BEARISH_SINGULARITYï¼ˆå¥‡ç‚¹çœ‹ç©ºï¼‰
        if tension > self.TENSION_THRESHOLD and acceleration < -self.ACCEL_THRESHOLD:
            if dxy_fuel > 0.1:
                return "BEARISH_SINGULARITY", "å¼ºå¥‡ç‚¹çœ‹ç©º (å®è§‚å¤±é€Ÿ)", 0.9
            else:
                return "BEARISH_SINGULARITY", "å¥‡ç‚¹çœ‹ç©º (åŠ¨åŠ›å¤±é€Ÿ)", 0.7

        # 2. BULLISH_SINGULARITYï¼ˆå¥‡ç‚¹çœ‹æ¶¨ï¼‰
        if tension < -self.TENSION_THRESHOLD and acceleration > self.ACCEL_THRESHOLD:
            if dxy_fuel > 0.2:
                return "BULLISH_SINGULARITY", "è¶…å¼ºå¥‡ç‚¹çœ‹æ¶¨ (ç‡ƒæ–™çˆ†ç‚¸)", 0.95
            elif dxy_fuel > 0:
                return "BULLISH_SINGULARITY", "å¼ºå¥‡ç‚¹çœ‹æ¶¨ (åŠ¨åŠ›å›å½’)", 0.8
            else:
                return "BULLISH_SINGULARITY", "å¥‡ç‚¹çœ‹æ¶¨ (å¼¹æ€§é‡Šæ”¾)", 0.6

        # 3. OSCILLATIONï¼ˆéœ‡è¡ï¼‰
        if abs(tension) < self.OSCILLATION_BAND and abs(acceleration) < self.ACCEL_THRESHOLD:
            return "OSCILLATION", "ç³»ç»Ÿå¹³è¡¡ (éœ‡è¡æ”¶æ•›)", 0.8

        # 4. HIGH_OSCILLATIONï¼ˆé«˜ä½éœ‡è¡ï¼‰
        if tension > 0.3 and abs(acceleration) < 0.01:
            return "HIGH_OSCILLATION", "é«˜ä½éœ‡è¡ (é£é™©ç§¯èš)", 0.6

        # 5. LOW_OSCILLATIONï¼ˆä½ä½éœ‡è¡ï¼‰
        if tension < -0.3 and abs(acceleration) < 0.01:
            return "LOW_OSCILLATION", "ä½ä½éœ‡è¡ (æœºä¼šç§¯èš)", 0.6

        # 6. TRANSITIONï¼ˆè¿‡æ¸¡çŠ¶æ€ï¼‰
        if tension > 0 and acceleration > 0:
            return "TRANSITION_UP", "å‘ä¸Šè¿‡æ¸¡ (è“„åŠ›)", 0.4
        elif tension < 0 and acceleration < 0:
            return "TRANSITION_DOWN", "å‘ä¸‹è¿‡æ¸¡ (æ³„åŠ›)", 0.4

        return "TRANSITION", "ä½“åˆ¶åˆ‡æ¢ä¸­", 0.3
```

---

#### 3.2 ç½®ä¿¡åº¦è¯„ä¼°

**åŠŸèƒ½**ï¼šè¯„ä¼°ä¿¡å·çš„å¯ä¿¡åº¦

**éœ€è¦çš„ä»£ç **ï¼š
```python
def evaluate_confidence(signal_type: str,
                       base_confidence: float,
                       dxy_fuel: float) -> float:
    """è¯„ä¼°ç½®ä¿¡åº¦

    å‚æ•°:
        signal_type: ä¿¡å·ç±»å‹
        base_confidence: åŸºç¡€ç½®ä¿¡åº¦
        dxy_fuel: DXYç‡ƒæ–™

    è¿”å›:
        æœ€ç»ˆç½®ä¿¡åº¦
    """
    # DXYç‡ƒæ–™å¢å¼º
    if abs(dxy_fuel) > 0.2:
        base_confidence = min(base_confidence + 0.1, 0.95)

    return base_confidence
```

---

#### 3.3 DXYå¢å¼ºåˆ¤æ–­

**åŠŸèƒ½**ï¼šåˆ¤æ–­æ˜¯å¦éœ€è¦DXYå¢å¼º

**éœ€è¦çš„ä»£ç **ï¼š
```python
def should_enhance_with_dxy(signal_type: str, dxy_fuel: float) -> bool:
    """åˆ¤æ–­æ˜¯å¦éœ€è¦DXYå¢å¼º

    å‚æ•°:
        signal_type: ä¿¡å·ç±»å‹
        dxy_fuel: DXYç‡ƒæ–™

    è¿”å›:
        æ˜¯å¦éœ€è¦DXYå¢å¼º
    """
    # åšå¤šä¿¡å· + DXYç‡ƒæ–™ > 0.2
    if signal_type in ['BULLISH_SINGULARITY', 'LOW_OSCILLATION']:
        return dxy_fuel > 0.2

    # åšç©ºä¿¡å· + DXYç‡ƒæ–™ < -0.2
    if signal_type in ['BEARISH_SINGULARITY', 'HIGH_OSCILLATION']:
        return dxy_fuel < -0.2

    return False
```

---

### æ¨¡å—4ï¼šäº¤æ˜“å†³ç­–ï¼ˆç¬¬3å±‚ï¼‰

#### 4.1 V8.0åå‘ç­–ç•¥æ˜ å°„

**åŠŸèƒ½**ï¼šå°†å¸‚åœºçŠ¶æ€æ˜ å°„åˆ°äº¤æ˜“åŠ¨ä½œ

**éœ€è¦çš„ä»£ç **ï¼š
```python
class V8ReverseStrategy:
    """V8.0åå‘ç­–ç•¥"""

    def __init__(self):
        # ç­–ç•¥æ˜ å°„è¡¨
        self.strategy_map = {
            'BEARISH_SINGULARITY': ('LONG', 'æŠ„åº•'),
            'BULLISH_SINGULARITY': ('SHORT', 'é€ƒé¡¶'),
            'LOW_OSCILLATION': ('LONG', 'ä½ä½åšå¤š'),
            'HIGH_OSCILLATION': ('SHORT', 'é«˜ä½åšç©º'),
            'OSCILLATION': ('WAIT', 'éœ‡è¡è§‚æœ›'),
            'TRANSITION_UP': ('WAIT', 'å‘ä¸Šè¿‡æ¸¡'),
            'TRANSITION_DOWN': ('WAIT', 'å‘ä¸‹è¿‡æ¸¡'),
            'TRANSITION': ('WAIT', 'ä½“åˆ¶åˆ‡æ¢')
        }

    def get_action(self, signal_type: str) -> Tuple[str, str]:
        """è·å–äº¤æ˜“åŠ¨ä½œ

        å‚æ•°:
            signal_type: ä¿¡å·ç±»å‹

        è¿”å›:
            (åŠ¨ä½œ, ç†ç”±)
        """
        action, reason_base = self.strategy_map.get(signal_type, ('WAIT', 'æœªçŸ¥çŠ¶æ€'))

        # æ„é€ å®Œæ•´ç†ç”±
        reason = f"{signal_type} â†’ {reason_base}"

        return action, reason
```

---

#### 4.2 åŸºç¡€ä»“ä½è®¡ç®—

**åŠŸèƒ½**ï¼šæ ¹æ®ç½®ä¿¡åº¦è®¡ç®—åŸºç¡€ä»“ä½

**éœ€è¦çš„ä»£ç **ï¼š
```python
def calculate_base_position(confidence: float) -> float:
    """è®¡ç®—åŸºç¡€ä»“ä½

    å‚æ•°:
        confidence: ç½®ä¿¡åº¦

    è¿”å›:
        åŸºç¡€ä»“ä½ï¼ˆå€æ•°ï¼‰
    """
    # åŸºç¡€å…¬å¼ï¼š1.0 + (confidence - 0.6) Ã— 0.5
    base_size = 1.0 + (confidence - 0.6) * 0.5

    # é™åˆ¶èŒƒå›´ [0.8, 1.5]
    base_size = max(0.8, min(base_size, 1.5))

    return base_size
```

---

#### 4.3 DXYå¢å¼ºä»“ä½

**åŠŸèƒ½**ï¼šæ ¹æ®DXYç‡ƒæ–™å¢å¼ºä»“ä½

**éœ€è¦çš„ä»£ç **ï¼š
```python
def apply_dxy_enhancement(base_size: float,
                         signal_type: str,
                         dxy_fuel: float) -> Tuple[float, str]:
    """åº”ç”¨DXYå¢å¼º

    å‚æ•°:
        base_size: åŸºç¡€ä»“ä½
        signal_type: ä¿¡å·ç±»å‹
        dxy_fuel: DXYç‡ƒæ–™

    è¿”å›:
        (å¢å¼ºåä»“ä½, å¢å¼ºè¯´æ˜)
    """
    enhanced_size = base_size
    enhancement = ""

    # åšå¤šä¿¡å· + DXYç‡ƒæ–™ > 0.2
    if signal_type in ['BULLISH_SINGULARITY', 'LOW_OSCILLATION']:
        if dxy_fuel > 0.2:
            enhanced_size *= 1.2
            enhancement = f" + DXYç‡ƒæ–™å¢å¼º({dxy_fuel:.2f})"

    # åšç©ºä¿¡å· + DXYç‡ƒæ–™ < -0.2
    elif signal_type in ['BEARISH_SINGULARITY', 'HIGH_OSCILLATION']:
        if dxy_fuel < -0.2:
            enhanced_size *= 1.2
            enhancement = f" + DXYç‡ƒæ–™å¢å¼º({dxy_fuel:.2f})"

    return enhanced_size, enhancement
```

---

#### 4.4 é£é™©æ§åˆ¶ä»“ä½

**åŠŸèƒ½**ï¼šæ ¹æ®é£é™©æ§åˆ¶é™åˆ¶æœ€ç»ˆä»“ä½

**éœ€è¦çš„ä»£ç **ï¼š
```python
def apply_risk_control(strategy_size: float,
                      account_balance: float,
                      risk_per_trade: float,
                      stop_loss_pct: float = 0.03) -> float:
    """åº”ç”¨é£é™©æ§åˆ¶

    å‚æ•°:
        strategy_size: ç­–ç•¥ä»“ä½ï¼ˆå€æ•°ï¼‰
        account_balance: è´¦æˆ·ä½™é¢
        risk_per_trade: å•ç¬”é£é™©
        stop_loss_pct: æ­¢æŸç™¾åˆ†æ¯”

    è¿”å›:
        å®é™…ä»“ä½é‡‘é¢
    """
    # ç­–ç•¥ä»“ä½
    strategy_position = account_balance * strategy_size

    # é£é™©æ§åˆ¶æœ€å¤§ä»“ä½
    max_position_by_risk = account_balance * (risk_per_trade / stop_loss_pct)

    # å–è¾ƒå°å€¼
    actual_position = min(strategy_position, max_position_by_risk)

    return actual_position
```

---

### æ¨¡å—5ï¼šé£é™©ç®¡ç†ï¼ˆç¬¬4å±‚ï¼‰

#### 5.1 æ­¢æŸè®¾ç½®

**åŠŸèƒ½**ï¼šè®¡ç®—æ­¢æŸä»·æ ¼

**éœ€è¦çš„ä»£ç **ï¼š
```python
def calculate_stop_loss(entry_price: float,
                       action: str,
                       stop_loss_pct: float = 0.03) -> float:
    """è®¡ç®—æ­¢æŸä»·æ ¼

    å‚æ•°:
        entry_price: å…¥åœºä»·æ ¼
        action: äº¤æ˜“æ–¹å‘ï¼ˆLONG/SHORTï¼‰
        stop_loss_pct: æ­¢æŸç™¾åˆ†æ¯”

    è¿”å›:
        æ­¢æŸä»·æ ¼
    """
    if action == 'LONG':
        # åšå¤šï¼šæ­¢æŸåœ¨ä¸‹æ–¹
        return entry_price * (1 - stop_loss_pct)
    else:
        # åšç©ºï¼šæ­¢æŸåœ¨ä¸Šæ–¹
        return entry_price * (1 + stop_loss_pct)
```

---

#### 5.2 æ­¢ç›ˆè®¾ç½®

**åŠŸèƒ½**ï¼šè®¡ç®—æ­¢ç›ˆä»·æ ¼

**éœ€è¦çš„ä»£ç **ï¼š
```python
def calculate_take_profit(entry_price: float,
                         action: str,
                         take_profit_pct: float = 0.10) -> float:
    """è®¡ç®—æ­¢ç›ˆä»·æ ¼

    å‚æ•°:
        entry_price: å…¥åœºä»·æ ¼
        action: äº¤æ˜“æ–¹å‘ï¼ˆLONG/SHORTï¼‰
        take_profit_pct: æ­¢ç›ˆç™¾åˆ†æ¯”

    è¿”å›:
        æ­¢ç›ˆä»·æ ¼
    """
    if action == 'LONG':
        # åšå¤šï¼šæ­¢ç›ˆåœ¨ä¸Šæ–¹
        return entry_price * (1 + take_profit_pct)
    else:
        # åšç©ºï¼šæ­¢ç›ˆåœ¨ä¸‹æ–¹
        return entry_price * (1 - take_profit_pct)
```

---

#### 5.3 ä¿¡å·æ¶ˆå¤±æ£€æµ‹

**åŠŸèƒ½**ï¼šæ£€æµ‹ä¿¡å·æ˜¯å¦æ¶ˆå¤±

**éœ€è¦çš„ä»£ç **ï¼š
```python
def check_signal_disappeared(current_confidence: float,
                            threshold: float = 0.5) -> bool:
    """æ£€æµ‹ä¿¡å·æ˜¯å¦æ¶ˆå¤±

    å‚æ•°:
        current_confidence: å½“å‰ç½®ä¿¡åº¦
        threshold: é˜ˆå€¼

    è¿”å›:
        æ˜¯å¦ä¿¡å·æ¶ˆå¤±
    """
    return current_confidence < threshold
```

---

#### 5.4 æŒä»“ç›‘æ§

**åŠŸèƒ½**ï¼šç›‘æ§æŒä»“çŠ¶æ€

**éœ€è¦çš„ä»£ç **ï¼š
```python
class PositionMonitor:
    """æŒä»“ç›‘æ§å™¨"""

    def __init__(self, position: Dict):
        self.position = position

    def check(self, current_price: float, current_confidence: float) -> Tuple[bool, str]:
        """æ£€æŸ¥æŒä»“çŠ¶æ€

        å‚æ•°:
            current_price: å½“å‰ä»·æ ¼
            current_confidence: å½“å‰ç½®ä¿¡åº¦

        è¿”å›:
            (æ˜¯å¦å¹³ä»“, ç†ç”±)
        """
        entry_price = self.position['entry_price']
        side = self.position['side']
        stop_loss = self.position['stop_loss']
        take_profit = self.position['take_profit']

        # è®¡ç®—ç›ˆäº
        if side == 'LONG':
            pnl_ratio = (current_price - entry_price) / entry_price
        else:
            pnl_ratio = (entry_price - current_price) / entry_price

        # 1. æ­¢æŸæ£€æŸ¥
        if pnl_ratio < -0.03:
            return True, f"æ­¢æŸ ({pnl_ratio:.2%})"

        # 2. æ­¢ç›ˆæ£€æŸ¥
        if pnl_ratio > 0.10:
            return True, f"æ­¢ç›ˆ ({pnl_ratio:.2%})"

        # 3. ä¿¡å·æ¶ˆå¤±æ£€æŸ¥
        if current_confidence < 0.5:
            return True, "ä¿¡å·æ¶ˆå¤±"

        # 4. ä»·æ ¼è§¦å‘æ£€æŸ¥
        if side == 'LONG':
            if current_price <= stop_loss:
                return True, "è§¦å‘æ­¢æŸä»·"
            if current_price >= take_profit:
                return True, "è§¦å‘æ­¢ç›ˆä»·"
        else:
            if current_price >= stop_loss:
                return True, "è§¦å‘æ­¢æŸä»·"
            if current_price <= take_profit:
                return True, "è§¦å‘æ­¢ç›ˆä»·"

        return False, ""
```

---

### æ¨¡å—6ï¼šè®¢å•æ‰§è¡Œ

#### 6.1 å¼€ä»“é€»è¾‘

**åŠŸèƒ½**ï¼šæ‰§è¡Œå¼€ä»“

**éœ€è¦çš„ä»£ç **ï¼š
```python
class OrderExecutor:
    """è®¢å•æ‰§è¡Œå™¨"""

    def __init__(self):
        self.positions: List[Dict] = []

    def open_position(self,
                     signal: Dict,
                     account_balance: float,
                     risk_per_trade: float) -> Dict:
        """å¼€ä»“

        å‚æ•°:
            signal: äº¤æ˜“ä¿¡å·
            account_balance: è´¦æˆ·ä½™é¢
            risk_per_trade: å•ç¬”é£é™©

        è¿”å›:
            æŒä»“ä¿¡æ¯
        """
        action = signal['action']
        entry_price = signal['current_price']
        confidence = signal['confidence']

        # è®¡ç®—ä»“ä½
        base_size = calculate_base_position(confidence)
        enhanced_size, _ = apply_dxy_enhancement(
            base_size,
            signal['signal_type'],
            signal.get('dxy_fuel', 0)
        )
        position_value = apply_risk_control(
            enhanced_size,
            account_balance,
            risk_per_trade
        )

        # è®¡ç®—æ­¢æŸæ­¢ç›ˆ
        stop_loss = calculate_stop_loss(entry_price, action, 0.03)
        take_profit = calculate_take_profit(entry_price, action, 0.10)

        # åˆ›å»ºæŒä»“
        position = {
            'entry_time': datetime.now(),
            'entry_price': entry_price,
            'size': position_value,
            'side': action,
            'stop_loss': stop_loss,
            'take_profit': take_profit,
            'signal_type': signal['signal_type'],
            'confidence': confidence,
            'reason': signal['reason']
        }

        self.positions.append(position)

        return position
```

---

#### 6.2 å¹³ä»“é€»è¾‘

**åŠŸèƒ½**ï¼šæ‰§è¡Œå¹³ä»“

**éœ€è¦çš„ä»£ç **ï¼š
```python
def close_position(self,
                  position: Dict,
                  current_price: float,
                  reason: str) -> Tuple[float, str]:
    """å¹³ä»“

    å‚æ•°:
        position: æŒä»“ä¿¡æ¯
        current_price: å½“å‰ä»·æ ¼
        reason: å¹³ä»“ç†ç”±

    è¿”å›:
        (ç›ˆäºæ¯”ä¾‹, æè¿°)
    """
    entry_price = position['entry_price']
    side = position['side']
    size = position['size']

    # è®¡ç®—ç›ˆäº
    if side == 'LONG':
        pnl_ratio = (current_price - entry_price) / entry_price
    else:
        pnl_ratio = (entry_price - current_price) / entry_price

    pnl_amount = size * pnl_ratio

    # ä»æŒä»“åˆ—è¡¨ä¸­ç§»é™¤
    if position in self.positions:
        self.positions.remove(position)

    description = f"{reason}: {pnl_ratio:+.2%} (${pnl_amount:+,.0f})"

    return pnl_ratio, description
```

---

#### 6.3 ä»“ä½æ›´æ–°

**åŠŸèƒ½**ï¼šæ›´æ–°è´¦æˆ·ä½™é¢

**éœ€è¦çš„ä»£ç **ï¼š
```python
class AccountManager:
    """è´¦æˆ·ç®¡ç†å™¨"""

    def __init__(self, initial_balance: float):
        self.balance = initial_balance
        self.initial_balance = initial_balance
        self.total_pnl = 0.0

    def update_balance(self, pnl_amount: float):
        """æ›´æ–°ä½™é¢

        å‚æ•°:
            pnl_amount: ç›ˆäºé‡‘é¢
        """
        self.balance += pnl_amount
        self.total_pnl += pnl_amount

    def get_performance(self) -> Dict:
        """è·å–æ€§èƒ½ç»Ÿè®¡

        è¿”å›:
            æ€§èƒ½ç»Ÿè®¡å­—å…¸
        """
        total_return = (self.balance - self.initial_balance) / self.initial_balance

        return {
            'balance': self.balance,
            'initial_balance': self.initial_balance,
            'total_pnl': self.total_pnl,
            'total_return': total_return
        }
```

---

### æ¨¡å—7ï¼šæ—¥å¿—è®°å½•

#### 7.1 äº¤æ˜“æ—¥å¿—

**åŠŸèƒ½**ï¼šè®°å½•äº¤æ˜“æ—¥å¿—

**éœ€è¦çš„ä»£ç **ï¼š
```python
class TradingLogger:
    """äº¤æ˜“æ—¥å¿—è®°å½•å™¨"""

    def __init__(self, log_file: str = 'live_trading_log.csv'):
        self.log_file = log_file
        self.logs: List[Dict] = []

    def log_open(self, position: Dict):
        """è®°å½•å¼€ä»“

        å‚æ•°:
            position: æŒä»“ä¿¡æ¯
        """
        log_entry = {
            'æ—¶é—´': position['entry_time'].strftime('%Y-%m-%d %H:%M:%S'),
            'åŠ¨ä½œ': 'OPEN',
            'ä¿¡å·ç±»å‹': position['signal_type'],
            'ç½®ä¿¡åº¦': f"{position['confidence']:.1%}",
            'æ–¹å‘': position['side'],
            'ä»·æ ¼': f"${position['entry_price']:,.0f}",
            'ä»“ä½': f"${position['size']:,.0f}",
            'æ­¢æŸ': f"${position['stop_loss']:,.0f}",
            'æ­¢ç›ˆ': f"${position['take_profit']:,.0f}",
            'ç†ç”±': position['reason']
        }

        self.logs.append(log_entry)
        self._save()

    def log_close(self,
                  close_time: datetime,
                  pnl_ratio: float,
                  pnl_amount: float,
                  balance: float,
                  reason: str):
        """è®°å½•å¹³ä»“

        å‚æ•°:
            close_time: å¹³ä»“æ—¶é—´
            pnl_ratio: ç›ˆäºæ¯”ä¾‹
            pnl_amount: ç›ˆäºé‡‘é¢
            balance: å½“å‰ä½™é¢
            reason: å¹³ä»“ç†ç”±
        """
        log_entry = {
            'æ—¶é—´': close_time.strftime('%Y-%m-%d %H:%M:%S'),
            'åŠ¨ä½œ': 'CLOSE',
            'ç›ˆäº': f"{pnl_ratio:+.2%}",
            'é‡‘é¢': f"${pnl_amount:+,.0f}",
            'ä½™é¢': f"${balance:,.0f}",
            'ç†ç”±': reason
        }

        self.logs.append(log_entry)
        self._save()

    def _save(self):
        """ä¿å­˜åˆ°CSV"""
        df = pd.DataFrame(self.logs)
        df.to_csv(self.log_file, index=False, encoding='utf-8-sig')
```

---

#### 7.2 æ€§èƒ½ç»Ÿè®¡

**åŠŸèƒ½**ï¼šè®¡ç®—æ€§èƒ½ç»Ÿè®¡

**éœ€è¦çš„ä»£ç **ï¼š
```python
class PerformanceAnalyzer:
    """æ€§èƒ½åˆ†æå™¨"""

    @staticmethod
    def calculate_metrics(logs: List[Dict]) -> Dict:
        """è®¡ç®—æ€§èƒ½æŒ‡æ ‡

        å‚æ•°:
            logs: äº¤æ˜“æ—¥å¿—

        è¿”å›:
            æ€§èƒ½æŒ‡æ ‡å­—å…¸
        """
        trades = [log for log in logs if log['åŠ¨ä½œ'] in ['OPEN', 'CLOSE']]

        # æå–ç›ˆäº
        pnls = []
        for i in range(0, len(trades), 2):
            if i + 1 < len(trades):
                close_trade = trades[i + 1]
                if 'ç›ˆäº' in close_trade:
                    pnl_str = close_trade['ç›ˆäº'].replace('%', '').replace('+', '')
                    pnl = float(pnl_str) / 100
                    pnls.append(pnl)

        if not pnls:
            return {}

        # è®¡ç®—æŒ‡æ ‡
        win_trades = [pnl for pnl in pnls if pnl > 0]
        lose_trades = [pnl for pnl in pnls if pnl < 0]

        metrics = {
            'æ€»äº¤æ˜“æ•°': len(pnls),
            'ç›ˆåˆ©äº¤æ˜“': len(win_trades),
            'äºæŸäº¤æ˜“': len(lose_trades),
            'èƒœç‡': len(win_trades) / len(pnls) if pnls else 0,
            'æ€»ç›ˆäº': sum(pnls),
            'å¹³å‡ç›ˆåˆ©': np.mean(win_trades) if win_trades else 0,
            'å¹³å‡äºæŸ': np.mean(lose_trades) if lose_trades else 0,
            'ç›ˆäºæ¯”': abs(np.mean(win_trades) / np.mean(lose_trades)) if lose_trades else 0,
            'æœ€å¤§ç›ˆåˆ©': max(pnls) if pnls else 0,
            'æœ€å¤§äºæŸ': min(pnls) if pnls else 0
        }

        return metrics
```

---

#### 7.3 æ•°æ®ä¿å­˜

**åŠŸèƒ½**ï¼šä¿å­˜æ•°æ®åˆ°CSV

**éœ€è¦çš„ä»£ç **ï¼š
```python
class DataSaver:
    """æ•°æ®ä¿å­˜å™¨"""

    def __init__(self, data_file: str = 'market_data.csv'):
        self.data_file = data_file
        self.data: List[Dict] = []

    def save_market_data(self,
                        timestamp: datetime,
                        btc_price: float,
                        tension: float,
                        acceleration: float,
                        dxy_fuel: float,
                        signal_type: str,
                        confidence: float):
        """ä¿å­˜å¸‚åœºæ•°æ®

        å‚æ•°:
            timestamp: æ—¶é—´æˆ³
            btc_price: BTCä»·æ ¼
            tension: å¼ åŠ›
            acceleration: åŠ é€Ÿåº¦
            dxy_fuel: DXYç‡ƒæ–™
            signal_type: ä¿¡å·ç±»å‹
            confidence: ç½®ä¿¡åº¦
        """
        data_entry = {
            'æ—¶é—´': timestamp.strftime('%Y-%m-%d %H:%M:%S'),
            'BTCä»·æ ¼': btc_price,
            'å¼ åŠ›': tension,
            'åŠ é€Ÿåº¦': acceleration,
            'DXYç‡ƒæ–™': dxy_fuel,
            'ä¿¡å·ç±»å‹': signal_type,
            'ç½®ä¿¡åº¦': confidence
        }

        self.data.append(data_entry)

        # ä¿å­˜åˆ°CSV
        df = pd.DataFrame(self.data)
        df.to_csv(self.data_file, index=False, encoding='utf-8-sig')
```

---

### æ¨¡å—8ï¼šä¸»å¾ªç¯æ§åˆ¶

#### 8.1 å®šæ—¶æ£€æŸ¥

**åŠŸèƒ½**ï¼šå®šæ—¶æ£€æŸ¥ä¿¡å·

**éœ€è¦çš„ä»£ç **ï¼š
```python
import time

class TradingLoop:
    """äº¤æ˜“å¾ªç¯æ§åˆ¶å™¨"""

    def __init__(self, interval_seconds: int = 300):
        self.interval_seconds = interval_seconds
        self.running = False

    def start(self, callback):
        """å¯åŠ¨å¾ªç¯

        å‚æ•°:
            callback: å›è°ƒå‡½æ•°
        """
        self.running = True

        print(f"ç³»ç»Ÿå¯åŠ¨ï¼Œæ¯{self.interval_seconds}ç§’æ£€æŸ¥ä¸€æ¬¡")

        try:
            while self.running:
                # æ‰§è¡Œå›è°ƒ
                callback()

                # ç­‰å¾…
                time.sleep(self.interval_seconds)

        except KeyboardInterrupt:
            print("\nç³»ç»Ÿåœæ­¢")
            self.running = False

    def stop(self):
        """åœæ­¢å¾ªç¯"""
        self.running = False
```

---

#### 8.2 çŠ¶æ€ç®¡ç†

**åŠŸèƒ½**ï¼šç®¡ç†ç³»ç»ŸçŠ¶æ€

**éœ€è¦çš„ä»£ç **ï¼š
```python
class StateManager:
    """çŠ¶æ€ç®¡ç†å™¨"""

    def __init__(self):
        self.current_position: Optional[Dict] = None
        self.last_signal: Optional[Dict] = None
        self.market_data: Optional[Dict] = None

    def update_position(self, position: Optional[Dict]):
        """æ›´æ–°æŒä»“"""
        self.current_position = position

    def update_signal(self, signal: Optional[Dict]):
        """æ›´æ–°ä¿¡å·"""
        self.last_signal = signal

    def update_market_data(self, data: Optional[Dict]):
        """æ›´æ–°å¸‚åœºæ•°æ®"""
        self.market_data = data

    def has_position(self) -> bool:
        """æ˜¯å¦æœ‰æŒä»“"""
        return self.current_position is not None

    def get_state_summary(self) -> Dict:
        """è·å–çŠ¶æ€æ‘˜è¦"""
        return {
            'has_position': self.has_position(),
            'position_side': self.current_position['side'] if self.current_position else None,
            'last_signal': self.last_signal['signal_type'] if self.last_signal else None,
            'market_price': self.market_data['btc_price'] if self.market_data else None
        }
```

---

#### 8.3 é”™è¯¯å¤„ç†

**åŠŸèƒ½**ï¼šå¤„ç†é”™è¯¯

**éœ€è¦çš„ä»£ç **ï¼š
```python
class ErrorHandler:
    """é”™è¯¯å¤„ç†å™¨"""

    @staticmethod
    def handle_error(error: Exception, context: str = ""):
        """å¤„ç†é”™è¯¯

        å‚æ•°:
            error: å¼‚å¸¸å¯¹è±¡
            context: ä¸Šä¸‹æ–‡ä¿¡æ¯
        """
        error_msg = f"[ERROR] {context}: {str(error)}"
        print(error_msg)

        # è®°å½•åˆ°æ—¥å¿—
        with open('error_log.txt', 'a', encoding='utf-8') as f:
            f.write(f"{datetime.now()}: {error_msg}\n")

    @staticmethod
    def handle_warning(warning: str, context: str = ""):
        """å¤„ç†è­¦å‘Š

        å‚æ•°:
            warning: è­¦å‘Šä¿¡æ¯
            context: ä¸Šä¸‹æ–‡ä¿¡æ¯
        """
        warning_msg = f"[WARNING] {context}: {warning}"
        print(warning_msg)
```

---

### æ¨¡å—9ï¼šæ•°æ®æ”¶é›†ï¼ˆç‹¬ç«‹è¿›ç¨‹ï¼‰

#### 9.1 å®šæ—¶æ”¶é›†

**åŠŸèƒ½**ï¼šå®šæ—¶æ”¶é›†æ•°æ®

**éœ€è¦çš„ä»£ç **ï¼š
```python
import schedule

class DataCollector:
    """æ•°æ®æ”¶é›†å™¨ï¼ˆç‹¬ç«‹è¿›ç¨‹ï¼‰"""

    def __init__(self, interval_hours: int = 4):
        self.interval_hours = interval_hours
        self.running = False

        # åˆå§‹åŒ–æ¨¡å—
        self.btc_fetcher = BTCDataFetcher()
        self.dxy_fetcher = DXYDataFetcher()
        self.data_saver = DataSaver('realtime_data.csv')

    def collect_once(self):
        """æ”¶é›†ä¸€æ¬¡æ•°æ®"""
        try:
            print(f"[{datetime.now()}] å¼€å§‹æ”¶é›†æ•°æ®...")

            # è·å–BTCæ•°æ®
            btc_df = self.btc_fetcher.fetch()
            if btc_df is None:
                print("[ERROR] BTCæ•°æ®è·å–å¤±è´¥")
                return

            # è·å–DXYæ•°æ®
            dxy_df = self.dxy_fetcher.fetch()
            dxy_latest = dxy_df['Close'].iloc[-1] if dxy_df is not None else None

            # è®¡ç®—æŒ‡æ ‡
            prices = btc_df['close'].tail(100).values
            tension, acceleration = self._calculate_indicators(prices)

            # ä¿å­˜æ•°æ®
            self.data_saver.save_market_data(
                timestamp=datetime.now(),
                btc_price=btc_df['close'].iloc[-1],
                tension=tension if tension else 0,
                acceleration=acceleration if acceleration else 0,
                dxy_fuel=0,  # ç®€åŒ–
                signal_type='N/A',
                confidence=0
            )

            print(f"[{datetime.now()}] æ•°æ®æ”¶é›†å®Œæˆ")

        except Exception as e:
            print(f"[ERROR] æ•°æ®æ”¶é›†å¤±è´¥: {e}")

    def _calculate_indicators(self, prices: np.ndarray) -> Tuple[Optional[float], Optional[float]]:
        """è®¡ç®—æŒ‡æ ‡ï¼ˆç®€åŒ–ç‰ˆï¼‰"""
        try:
            # é¢„å¤„ç†
            d_prices = preprocess_prices(prices)

            # FFTæ»¤æ³¢
            filtered = fft_filter(d_prices)

            # Hilbertå˜æ¢
            tension_raw = hilbert_transform(filtered)

            # æ ‡å‡†åŒ–
            tension_norm = normalize_tension(tension_raw)

            # è®¡ç®—åŠ é€Ÿåº¦
            tension, acceleration = calculate_acceleration(tension_norm)

            return tension, acceleration

        except Exception as e:
            print(f"[ERROR] æŒ‡æ ‡è®¡ç®—å¤±è´¥: {e}")
            return None, None

    def start(self):
        """å¯åŠ¨æ•°æ®æ”¶é›†"""
        self.running = True

        print(f"æ•°æ®æ”¶é›†ç³»ç»Ÿå¯åŠ¨ï¼Œæ¯{self.interval_hours}å°æ—¶æ”¶é›†ä¸€æ¬¡")

        # ç«‹å³æ‰§è¡Œä¸€æ¬¡
        self.collect_once()

        # å®šæ—¶æ‰§è¡Œ
        schedule.every(self.interval_hours).hours.do(self.collect_once)

        try:
            while self.running:
                schedule.run_pending()
                time.sleep(60)  # æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡

        except KeyboardInterrupt:
            print("\næ•°æ®æ”¶é›†ç³»ç»Ÿåœæ­¢")
            self.running = False
```

---

#### 9.2 æ•°æ®å­˜å‚¨

**åŠŸèƒ½**ï¼šå­˜å‚¨å†å²æ•°æ®ï¼ˆå·²åœ¨æ¨¡å—7.3ä¸­å®ç°ï¼‰

---

#### 9.3 å†å²ç®¡ç†

**åŠŸèƒ½**ï¼šç®¡ç†å†å²æ•°æ®

**éœ€è¦çš„ä»£ç **ï¼š
```python
class HistoryManager:
    """å†å²æ•°æ®ç®¡ç†å™¨"""

    def __init__(self, max_days: int = 30):
        self.max_days = max_days

    def clean_old_data(self, data_file: str):
        """æ¸…ç†æ—§æ•°æ®

        å‚æ•°:
            data_file: æ•°æ®æ–‡ä»¶è·¯å¾„
        """
        try:
            df = pd.read_csv(data_file, encoding='utf-8-sig')
            df['æ—¶é—´'] = pd.to_datetime(df['æ—¶é—´'])

            # åªä¿ç•™æœ€è¿‘çš„æ•°æ®
            cutoff_date = datetime.now() - timedelta(days=self.max_days)
            df_filtered = df[df['æ—¶é—´'] >= cutoff_date]

            # ä¿å­˜
            df_filtered.to_csv(data_file, index=False, encoding='utf-8-sig')

            print(f"[æ¸…ç†] åˆ é™¤äº†{len(df) - len(df_filtered)}æ¡æ—§æ•°æ®")

        except Exception as e:
            print(f"[ERROR] æ•°æ®æ¸…ç†å¤±è´¥: {e}")

    def get_history(self, data_file: str, days: int = 7) -> pd.DataFrame:
        """è·å–å†å²æ•°æ®

        å‚æ•°:
            data_file: æ•°æ®æ–‡ä»¶è·¯å¾„
            days: è·å–æœ€è¿‘å¤šå°‘å¤©çš„æ•°æ®

        è¿”å›:
            å†å²æ•°æ®DataFrame
        """
        try:
            df = pd.read_csv(data_file, encoding='utf-8-sig')
            df['æ—¶é—´'] = pd.to_datetime(df['æ—¶é—´'])

            cutoff_date = datetime.now() - timedelta(days=days)
            df_filtered = df[df['æ—¶é—´'] >= cutoff_date]

            return df_filtered

        except Exception as e:
            print(f"[ERROR] è¯»å–å†å²æ•°æ®å¤±è´¥: {e}")
            return pd.DataFrame()
```

---

## ğŸ“Š å®Œæ•´é›†æˆç¤ºä¾‹

### ä¸»ç¨‹åº

**åŠŸèƒ½**ï¼šå°†æ‰€æœ‰æ¨¡å—é›†æˆåˆ°ä¸€èµ·

**éœ€è¦çš„ä»£ç **ï¼š
```python
class LiveTradingSystem:
    """å®ç›˜äº¤æ˜“ç³»ç»Ÿï¼ˆå®Œæ•´ç‰ˆï¼‰"""

    def __init__(self,
                 account_balance: float = 10000,
                 risk_per_trade: float = 0.02,
                 interval_seconds: int = 300):

        # åˆå§‹åŒ–æ‰€æœ‰æ¨¡å—
        self.btc_fetcher = BTCDataFetcher()
        self.dxy_fetcher = DXYDataFetcher()
        self.data_cache = DataCache(max_size=100)

        # ç‰©ç†æŒ‡æ ‡è®¡ç®—
        self.market_classifier = MarketStateClassifier()
        self.v8_strategy = V8ReverseStrategy()

        # è®¢å•æ‰§è¡Œ
        self.order_executor = OrderExecutor()
        self.position_monitor = None  # æœ‰æŒä»“æ—¶åˆå§‹åŒ–

        # æ—¥å¿—è®°å½•
        self.trading_logger = TradingLogger()
        self.data_saver = DataSaver()
        self.account_manager = AccountManager(account_balance)

        # çŠ¶æ€ç®¡ç†
        self.state_manager = StateManager()
        self.error_handler = ErrorHandler()

        # é…ç½®
        self.risk_per_trade = risk_per_trade
        self.interval_seconds = interval_seconds

    def check_and_trade(self):
        """æ£€æŸ¥å¹¶äº¤æ˜“ï¼ˆä¸»å¾ªç¯å›è°ƒï¼‰"""
        try:
            # ç¬¬0å±‚ï¼šæ•°æ®è·å–
            btc_df = self.btc_fetcher.fetch()
            if btc_df is None:
                return

            dxy_df = self.dxy_fetcher.fetch()
            dxy_latest = dxy_df['Close'].iloc[-1] if dxy_df is not None else None

            current_price = btc_df['close'].iloc[-1]
            current_volume = btc_df['volume'].iloc[-1]

            # æ›´æ–°ç¼“å­˜
            self.data_cache.update_price(current_price, current_volume)
            if dxy_latest:
                self.data_cache.update_dxy(dxy_latest)

            # æ£€æŸ¥æ•°æ®æ˜¯å¦è¶³å¤Ÿ
            if not self.data_cache.is_ready():
                print("[INFO] æ•°æ®ä¸è¶³ï¼Œç­‰å¾…æ›´å¤šæ•°æ®...")
                return

            # ç¬¬1å±‚ï¼šç‰©ç†æŒ‡æ ‡è®¡ç®—
            prices = self.data_cache.get_prices_array()
            tension, acceleration = self._calculate_indicators(prices)
            if tension is None:
                return

            dxy_fuel = calculate_dxy_fuel(self.data_cache.dxy_history)

            # ç¬¬2å±‚ï¼šå¸‚åœºçŠ¶æ€è¯Šæ–­
            signal_type, description, confidence = self.market_classifier.classify(
                tension, acceleration, dxy_fuel
            )

            # ä¿å­˜å¸‚åœºæ•°æ®
            self.data_saver.save_market_data(
                timestamp=datetime.now(),
                btc_price=current_price,
                tension=tension,
                acceleration=acceleration,
                dxy_fuel=dxy_fuel,
                signal_type=signal_type,
                confidence=confidence
            )

            # ç½®ä¿¡åº¦è¿‡æ»¤
            if confidence < 0.6:
                print(f"[INFO] ç½®ä¿¡åº¦ä¸è¶³ ({confidence:.1%})")
                return

            # ç¬¬3å±‚ï¼šäº¤æ˜“å†³ç­–
            action, reason = self.v8_strategy.get_action(signal_type)

            if action == 'WAIT':
                print(f"[INFO] è§‚æœ›ï¼š{reason}")
                return

            # æ„é€ ä¿¡å·
            signal = {
                'action': action,
                'signal_type': signal_type,
                'confidence': confidence,
                'current_price': current_price,
                'tension': tension,
                'acceleration': acceleration,
                'dxy_fuel': dxy_fuel,
                'reason': reason
            }

            # ç¬¬4å±‚ï¼šé£é™©ç®¡ç† + è®¢å•æ‰§è¡Œ
            if not self.state_manager.has_position():
                # å¼€ä»“
                position = self.order_executor.open_position(
                    signal,
                    self.account_manager.balance,
                    self.risk_per_trade
                )

                self.state_manager.update_position(position)
                self.trading_logger.log_open(position)

                print(f"\n[å¼€ä»“] {action} ${position['size']:,.0f} @ ${current_price:,.0f}")
                print(f"  ç†ç”±: {reason}")
                print(f"  æ­¢æŸ: ${position['stop_loss']:,.0f}")
                print(f"  æ­¢ç›ˆ: ${position['take_profit']:,.0f}")

            else:
                # æœ‰æŒä»“ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦å¹³ä»“
                self._check_position(current_price, confidence)

        except Exception as e:
            self.error_handler.handle_error(e, "check_and_trade")

    def _calculate_indicators(self, prices: np.ndarray) -> Tuple[Optional[float], Optional[float]]:
        """è®¡ç®—ç‰©ç†æŒ‡æ ‡"""
        try:
            # é¢„å¤„ç†
            d_prices = preprocess_prices(prices)

            # FFTæ»¤æ³¢
            filtered = fft_filter(d_prices)

            # Hilbertå˜æ¢
            tension_raw = hilbert_transform(filtered)

            # æ ‡å‡†åŒ–
            tension_norm = normalize_tension(tension_raw)

            # è®¡ç®—åŠ é€Ÿåº¦
            tension, acceleration = calculate_acceleration(tension_norm)

            return tension, acceleration

        except Exception as e:
            self.error_handler.handle_error(e, "calculate_indicators")
            return None, None

    def _check_position(self, current_price: float, current_confidence: float):
        """æ£€æŸ¥æŒä»“"""
        try:
            position = self.state_manager.current_position

            # åˆå§‹åŒ–ç›‘æ§å™¨
            if self.position_monitor is None:
                self.position_monitor = PositionMonitor(position)

            # æ£€æŸ¥
            should_close, reason = self.position_monitor.check(
                current_price, current_confidence
            )

            if should_close:
                # å¹³ä»“
                pnl_ratio, description = self.order_executor.close_position(
                    position, current_price, reason
                )

                # æ›´æ–°è´¦æˆ·
                pnl_amount = position['size'] * pnl_ratio
                self.account_manager.update_balance(pnl_amount)

                # è®°å½•æ—¥å¿—
                self.trading_logger.log_close(
                    datetime.now(),
                    pnl_ratio,
                    pnl_amount,
                    self.account_manager.balance,
                    reason
                )

                print(f"\n[å¹³ä»“] {description}")
                print(f"  ä½™é¢: ${self.account_manager.balance:,.0f}")

                # æ¸…é™¤çŠ¶æ€
                self.state_manager.update_position(None)
                self.position_monitor = None

        except Exception as e:
            self.error_handler.handle_error(e, "check_position")

    def run(self):
        """è¿è¡Œç³»ç»Ÿ"""
        print("="*80)
        print("V8.0 å®ç›˜äº¤æ˜“ç³»ç»Ÿ - å®Œæ•´ç‰ˆ")
        print("="*80)
        print(f"\nè´¦æˆ·ä½™é¢: ${self.account_manager.balance:,.0f}")
        print(f"å•ç¬”é£é™©: {self.risk_per_trade:.1%}")
        print(f"æ£€æŸ¥é—´éš”: {self.interval_seconds}ç§’")
        print("\nç³»ç»Ÿå¯åŠ¨...\n")

        # å¯åŠ¨ä¸»å¾ªç¯
        loop = TradingLoop(self.interval_seconds)
        loop.start(self.check_and_trade)
```

---

## ğŸ¯ æ€»ç»“

### å®Œæ•´çš„æ¨¡å—åˆ—è¡¨

```
âœ… æ¨¡å—1ï¼šæ•°æ®è·å–å±‚ï¼ˆç¬¬0å±‚ï¼‰
   â”œâ”€ 1.1 BTCDataFetcher
   â”œâ”€ 1.2 DXYDataFetcher
   â””â”€ 1.3 DataCache

âœ… æ¨¡å—2ï¼šç‰©ç†æŒ‡æ ‡è®¡ç®—ï¼ˆç¬¬1å±‚ï¼‰
   â”œâ”€ 2.1 preprocess_prices()
   â”œâ”€ 2.2 fft_filter()
   â”œâ”€ 2.3 hilbert_transform()
   â”œâ”€ 2.4 normalize_tension()
   â”œâ”€ 2.5 calculate_acceleration()
   â””â”€ 2.6 calculate_dxy_fuel()

âœ… æ¨¡å—3ï¼šå¸‚åœºçŠ¶æ€è¯Šæ–­ï¼ˆç¬¬2å±‚ï¼‰
   â”œâ”€ 3.1 MarketStateClassifier
   â”œâ”€ 3.2 evaluate_confidence()
   â””â”€ 3.3 should_enhance_with_dxy()

âœ… æ¨¡å—4ï¼šäº¤æ˜“å†³ç­–ï¼ˆç¬¬3å±‚ï¼‰
   â”œâ”€ 4.1 V8ReverseStrategy
   â”œâ”€ 4.2 calculate_base_position()
   â”œâ”€ 4.3 apply_dxy_enhancement()
   â””â”€ 4.4 apply_risk_control()

âœ… æ¨¡å—5ï¼šé£é™©ç®¡ç†ï¼ˆç¬¬4å±‚ï¼‰
   â”œâ”€ 5.1 calculate_stop_loss()
   â”œâ”€ 5.2 calculate_take_profit()
   â”œâ”€ 5.3 check_signal_disappeared()
   â””â”€ 5.4 PositionMonitor

âœ… æ¨¡å—6ï¼šè®¢å•æ‰§è¡Œ
   â”œâ”€ 6.1 OrderExecutor.open_position()
   â”œâ”€ 6.2 OrderExecutor.close_position()
   â””â”€ 6.3 AccountManager

âœ… æ¨¡å—7ï¼šæ—¥å¿—è®°å½•
   â”œâ”€ 7.1 TradingLogger
   â”œâ”€ 7.2 PerformanceAnalyzer
   â””â”€ 7.3 DataSaver

âœ… æ¨¡å—8ï¼šä¸»å¾ªç¯æ§åˆ¶
   â”œâ”€ 8.1 TradingLoop
   â”œâ”€ 8.2 StateManager
   â””â”€ 8.3 ErrorHandler

âœ… æ¨¡å—9ï¼šæ•°æ®æ”¶é›†ï¼ˆç‹¬ç«‹è¿›ç¨‹ï¼‰
   â”œâ”€ 9.1 DataCollector
   â”œâ”€ 9.2 DataSaver
   â””â”€ 9.3 HistoryManager
```

### ä½¿ç”¨æ–¹å¼

**å®ç›˜äº¤æ˜“**ï¼š
```python
system = LiveTradingSystem(
    account_balance=10000,
    risk_per_trade=0.02,
    interval_seconds=300
)
system.run()
```

**æ•°æ®æ”¶é›†**ï¼š
```python
collector = DataCollector(interval_hours=4)
collector.start()
```

---

**è¿™å°±æ˜¯å®Œæ•´çš„ä»£ç æ¶æ„ï¼ŒåŒ…å«äº†æ‰€æœ‰éœ€è¦çš„æ¨¡å—ï¼** ğŸ¯
