# 真实期权和订单流数据收集指南

为了进行准确的期权微观结构策略回测，需要收集以下两类历史数据：

---

## 一、期权数据 (Greeks.live)

### 所需字段

| 字段 | 说明 | 用途 |
|------|------|------|
| 时间 | 时间戳 | 数据对齐 |
| GEX | Gamma Exposure | 负Gamma陷阱检测 |
| ATM_IV | ATM隐含波动率 | IV分位数计算 |
| IV_1D | 1天期IV | 期限结构 |
| IV_1W | 1周IV | 期限结构 |
| IV_1M | 1月IV | 期限结构 |
| IV_3M | 3月IV | 期限结构 |
| Skew_Slope | Skew斜率 | 风险偏好 |
| Call_Skew | Call端Skew | 看涨情绪 |
| Put_Skew | Put端Skew | 看跌情绪 |
| Max_Pain | 最大痛点 | 支撑阻力 |
| Call_OI_Above | 上方Call持仓量 | Gamma Squeeze潜力 |

### 数据源选项

#### 选项1: Greeks.live API (推荐)

**申请步骤**:
1. 访问 https://greeks.live/
2. 联系 support@greeks.live 申请API访问
3. 获取API Key

**收集脚本**:
```python
# collect_options_data.py
import requests
import pandas as pd
from datetime import datetime, timedelta

def collect_historical_options_data(
    symbol='BTC',
    start_date='2024-01-01',
    end_date='2025-01-22',
    api_key='YOUR_API_KEY'
):
    """从Greeks.live收集历史期权数据"""

    base_url = 'https://api.greeks.live/v1'

    headers = {
        'Authorization': f'Bearer {api_key}',
        'Content-Type': 'application/json'
    }

    # 请求参数
    params = {
        'symbol': symbol,
        'start': start_date,
        'end': end_date,
        'interval': '4h',  # 4小时粒度，与策略匹配
        'fields': 'gex,atm_iv,iv_term_structure,skew,max_pain,open_interest'
    }

    try:
        response = requests.get(
            f'{base_url}/historical/options-metrics',
            headers=headers,
            params=params,
            timeout=30
        )
        response.raise_for_status()

        data = response.json()

        # 转换为DataFrame
        df = pd.DataFrame(data['data'])

        # 保存为CSV
        output_file = f'btc_options_history_{start_date}_{end_date}.csv'
        df.to_csv(output_file, index=False, encoding='utf-8-sig')

        print(f"[SUCCESS] Downloaded {len(df)} records")
        print(f"[SAVED] {output_file}")

        return df

    except requests.exceptions.HTTPError as e:
        print(f"[ERROR] HTTP Error: {e}")
        print(f"[HINT] Check your API key and permissions")

    except Exception as e:
        print(f"[ERROR] Failed to download: {e}")

    return None

if __name__ == '__main__':
    collect_historical_options_data()
```

#### 选项2: Deribit API (免费，但数据有限)

**收集脚本**:
```python
import requests
import pandas as pd
from datetime import datetime, timedelta

def collect_deribit_options_data(symbol='BTC', days=365):
    """从Deribit收集期权数据"""

    # Deribit API endpoint
    url = 'https://www.deribit.com/api/v2/public/get_volatility_index_data'

    # 获取历史波动率指数数据
    params = {
        'currency': symbol,
        'start_timestamp': int((datetime.now() - timedelta(days=days)).timestamp() * 1000),
        'end_timestamp': int(datetime.now().timestamp() * 1000),
        'resolution': '240'  # 4小时 = 240分钟
    }

    response = requests.get(url, params=params)
    data = response.json()

    if 'result' in data:
        df = pd.DataFrame(data['result'])
        df['时间'] = pd.to_datetime(df['timestamp'], unit='ms')

        # Deribit只提供BVOL数据，GEX需要自己计算
        df.to_csv('btc_options_deribit.csv', index=False, encoding='utf-8-sig')
        print(f"[OK] Downloaded {len(df)} records from Deribit")

    return df
```

#### 选项3: 使用第三方数据提供商

**推荐提供商**:
- **Laevitas**: https://laevitas.ch/ (付费，数据完整)
- **Glassnode**: https://glassnode.com/ (付费，专注链上数据)
- **Amberdata**: https://amberdata.io/ (付费，机构级数据)
- **Coinglass**: https://www.coinglass.com/ (部分免费)

---

## 二、订单流数据 (Exchange Data)

### 所需字段

| 字段 | 说明 | 用途 |
|------|------|------|
| 时间 | 时间戳 | 数据对齐 |
| CVD | Cumulative Volume Delta | 买卖力量对比 |
| VPIN | Volume-Synchronized PIN | 有毒流量 |
| Bid_Quantity_1pct | 1%买盘深度 | 流动性覆盖率 |
| Ask_Quantity_1pct | 1%卖盘深度 | 流动性覆盖率 |
| Sell_Pressure | 卖压强度 | 市场情绪 |
| Buy_Pressure | 买压强度 | 市场情绪 |
| Toxic_Flow_Ratio | 有毒流量占比 | 知情交易 |

### 数据源选项

#### 选项1: Binance Futures WebSocket (推荐，免费)

**收集脚本**:
```python
# collect_orderflow_data.py
import pandas as pd
from binance.client import Client
from binance.exceptions import BinanceAPIException
from datetime import datetime, timedelta
import time

def collect_binance_orderflow_data(
    symbol='BTCUSDT',
    interval='1h',
    days=365,
    use_api_key=False  # 设为True以提高速率限制
):
    """从Binance收集订单流数据"""

    if use_api_key:
        # 使用API Key可以获得更高的速率限制
        api_key = 'YOUR_BINANCE_API_KEY'
        api_secret = 'YOUR_BINANCE_API_SECRET'
        client = Client(api_key, api_secret)
    else:
        # 无需API Key，但速率限制较低
        client = Client()

    print(f"[Collecting] {symbol} orderflow data for {days} days...")

    # 获取历史K线数据
    klines = client.get_historical_klines(
        symbol,
        interval,
        start_str=str(datetime.now() - timedelta(days=days))
    )

    print(f"[Downloaded] {len(klines)} klines")

    # 处理数据
    data = []
    cvd = 0  # Cumulative Volume Delta

    for k in klines:
        timestamp = datetime.fromtimestamp(k[0] // 1000)
        open_price = float(k[1])
        high_price = float(k[2])
        low_price = float(k[3])
        close_price = float(k[4])
        volume = float(k[5])

        # 简化的CVD计算 (使用价格变化作为proxy)
        # 实际应该使用trade by trade数据
        price_change = close_price - open_price
        delta = price_change * volume

        cvd += delta

        # 计算买卖压力 (简化)
        if price_change > 0:
            buy_pressure = volume * 0.6
            sell_pressure = volume * 0.4
        else:
            buy_pressure = volume * 0.4
            sell_pressure = volume * 0.6

        # VPIN (简化)
        vpin = abs(buy_pressure - sell_pressure) / volume if volume > 0 else 0

        # 订单簿深度 (简化，使用成交量的proxy)
        bid_qty_1pct = volume * 100  # 假设流动性是成交量的100倍
        ask_qty_1pct = volume * 100

        data.append({
            '时间': timestamp,
            'CVD': cvd,
            'VPIN': vpin,
            'Bid_Quantity_1pct': bid_qty_1pct,
            'Ask_Quantity_1pct': ask_qty_1pct,
            'Sell_Pressure': sell_pressure,
            'Buy_Pressure': buy_pressure,
            'Toxic_Flow_Ratio': 0.2  # 简化假设
        })

    df = pd.DataFrame(data)

    # 计算CVD趋势
    df['CVD_Trend'] = df['CVD'].diff()
    df['Price_Trend'] = 0  # 需要价格数据计算

    # 保存
    output_file = f'btc_orderflow_binance_{days}days.csv'
    df.to_csv(output_file, index=False, encoding='utf-8-sig')

    print(f"[SUCCESS] Saved {len(df)} records to {output_file}")

    return df

def collect_binance_trade_by_trade(symbol='BTCUSDT', hours=24):
    """收集逐笔成交数据 (用于精确计算CVD)"""

    client = Client()

    # 获取最近成交
    trades = client.get_recent_trades(symbol=symbol, limit=1000)

    data = []
    cvd = 0

    for trade in trades:
        timestamp = datetime.fromtimestamp(trade['time'] / 1000)
        price = float(trade['price'])
        qty = float(trade['qty'])
        is_buyer_maker = trade['isBuyerMaker']

        # 买家主动买入 = 挂单成交 = CVD增加
        # 卖家主动卖出 = 吃单 = CVD减少
        if not is_buyer_maker:
            cvd += qty
        else:
            cvd -= qty

        data.append({
            '时间': timestamp,
            'Price': price,
            'Quantity': qty,
            'IsBuyerMaker': is_buyer_maker,
            'CVD': cvd
        })

    df = pd.DataFrame(data)
    df.to_csv(f'{symbol}_trades_{hours}h.csv', index=False, encoding='utf-8-sig')

    print(f"[OK] Collected {len(df)} trade records")

    return df

if __name__ == '__main__':
    # 收集K线数据
    collect_binance_orderflow_data(days=365)

    # 收集逐笔成交数据 (最近24小时)
    collect_binance_trade_by_trade(hours=24)
```

#### 选项2: 专用订单流提供商

**推荐提供商**:
- **Theta Terminal**: https://theta.network/ (专业订单流分析)
- **Footprint.ai**: https://footprint.ai/ (链上订单流)
- **Nansen**: https://www.nansen.ai/ (链上智能资金追踪)

---

## 三、数据收集后的步骤

### 1. 数据验证

```python
def validate_data(options_df, orderflow_df):
    """验证数据质量"""

    print("\n[Validation]")

    # 检查时间范围
    print(f"  Options data: {options_df['时间'].min()} to {options_df['时间'].max()}")
    print(f"  Orderflow data: {orderflow_df['时间'].min()} to {orderflow_df['时间'].max()}")

    # 检查缺失值
    print(f"  Options missing values: {options_df.isnull().sum().sum()}")
    print(f"  Orderflow missing values: {orderflow_df.isnull().sum().sum()}")

    # 检查数据连续性
    options_df['时间_diff'] = options_df['时间'].diff()
    gaps = options_df[options_df['时间_diff'] > pd.Timedelta('5h')]
    print(f"  Options data gaps: {len(gaps)}")

    # 检查异常值
    print(f"  GEX range: ${options_df['GEX'].min()/1e8:.2f}B to ${options_df['GEX'].max()/1e8:.2f}B")
    print(f"  IV range: {options_df['ATM_IV'].min():.2f}% to {options_df['ATM_IV'].max():.2f}%")
```

### 2. 数据对齐

```python
def align_data(price_df, options_df, orderflow_df):
    """对齐三个数据源"""

    # 设置时间为索引
    price_df = price_df.set_index('时间')
    options_df = options_df.set_index('时间')
    orderflow_df = orderflow_df.set_index('时间')

    # 使用4小时重采样
    price_4h = price_df.resample('4h').last()
    options_4h = options_df.resample('4h').last()
    orderflow_4h = orderflow_df.resample('4h').last()

    # 合并
    merged = pd.concat([
        price_4h,
        options_4h,
        orderflow_4h
    ], axis=1)

    # 前向填充缺失值
    merged = merged.fillna(method='ffill')

    return merged
```

### 3. 运行完整回测

```python
from backtest_microstructure_strategy import MicrostructureBacktester

# 使用真实数据
backtester = MicrostructureBacktester(
    price_data_filepath='带信号标记_完整数据_修复版.csv',
    options_data_filepath='btc_options_history.csv',
    orderflow_data_filepath='btc_orderflow_history.csv'
)

results = backtester.run_backtest(initial_capital=100000)
```

---

## 四、数据收集优先级

### 高优先级 (必须)

1. **GEX数据**: 负Gamma陷阱检测的核心
2. **IV数据**: 计算IV分位数，识别Vanna挤压
3. **CVD数据**: 检测吸筹背离

### 中优先级 (重要)

4. **订单簿深度**: 计算LCR流动性覆盖率
5. **VPIN**: 有毒流量检测
6. **Skew数据**: 风险偏好指标

### 低优先级 (可选)

7. **Max Pain**: 支撑阻力参考
8. **Open Interest**: Gamma Squeeze潜力分析

---

## 五、费用估算

| 数据源 | 类型 | 费用 | 覆盖范围 |
|--------|------|------|----------|
| Greeks.live | 期权 | $200-500/月 | 完整Greeks数据 |
| Deribit | 期权 | 免费 | 仅BVOL数据 |
| Binance | 订单流 | 免费 | K线 + 基础数据 |
| Theta Terminal | 订单流 | $100-300/月 | 专业订单流 |
| Glassnode | 综合 | $500-1000/月 | 链上+期权 |

**推荐方案**:
- **开发阶段**: Binance (免费) + Deribit (免费)
- **生产阶段**: Greeks.live (期权) + Binance (订单流)
- **机构级**: Laevitas (期权) + Theta Terminal (订单流)

---

## 六、联系信息

### Greeks.live
- **网站**: https://greeks.live/
- **Email**: support@greeks.live
- **Twitter**: @GreeksLive

### Binance API
- **文档**: https://binance-docs.github.io/apidocs/
- **GitHub**: https://github.com/binance/binance-connector-python

### Laevitas
- **网站**: https://laevitas.ch/
- **Email**: info@laevitas.ch

---

**下一步行动**:

1. ✅ 选择数据源（建议从免费API开始）
2. ⬜ 运行数据收集脚本
3. ⬜ 验证数据质量
4. ⬜ 运行完整回测
5. ⬜ 对比模拟结果与真实结果
6. ⬜ 优化策略参数

---

**创建时间**: 2026-01-22
**版本**: v1.0
